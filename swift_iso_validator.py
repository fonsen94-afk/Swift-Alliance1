"""
swift_iso_validator.py

ISO20022 (pain.001) XSD validator and basic MT103 structural validator.

Usage:
  - Install requirements (see requirements.txt)
  - Download the ISO20022 pain.001 XSD you need (e.g. pain.001.001.03.xsd or other version)
  - Call validate_pain001_xml(xml_string, schema_path) or validate_pain001_file(xml_path, schema_path)
  - Or use validate_mt103_text(mt_text) for a basic MT103 check.

Notes:
  - This module does NOT contact any external services.
  - It relies on xmlschema for XSD validation; xmlschema supports XML Schema 1.0.
"""

from typing import Tuple, List, Optional
import xmlschema
import io
import re
from xml.etree import ElementTree as ET

# Exceptions
class SchemaNotFoundError(FileNotFoundError):
    pass

def validate_pain001_xml(xml_string: str, schema_path: str) -> Tuple[bool, Optional[List[str]]]:
    """
    Validate a pain.001 XML string against the provided XSD file.

    Returns:
      (is_valid, None) if valid
      (False, [error messages...]) if invalid

    Example:
      valid, errors = validate_pain001_xml(xml_text, "schemas/pain.001.001.03.xsd")
    """
    # Load schema
    try:
        schema = xmlschema.XMLSchema(schema_path)
    except OSError as e:
        raise SchemaNotFoundError(f"Schema file not found: {schema_path}") from e
    except xmlschema.XMLSchemaException as e:
        # Problem parsing XSD
        return False, [f"Failed to load schema: {e}"]

    # Validate using iter_errors to gather full diagnostics
    errors = []
    try:
        for err in schema.iter_errors(xml_string):
            # xmlschema.exceptions.XMLSchemaValidationError has .path, .reason, .position, etc.
            pos = getattr(err, 'position', None)
            if pos:
                (line, col) = pos
                errors.append(f"Line {line}, Col {col}: {err.reason}")
            else:
                errors.append(str(err))
    except Exception as e:
        # If parsing the XML itself fails, xmlschema.iter_errors can raise
        return False, [f"Failed to parse/validate XML: {e}"]

    if errors:
        return False, errors
    return True, None


def validate_pain001_file(xml_path: str, schema_path: str) -> Tuple[bool, Optional[List[str]]]:
    """
    Read XML from file and validate. Returns same tuple as validate_pain001_xml.
    """
    try:
        with open(xml_path, 'rb') as f:
            xml_bytes = f.read()
    except OSError as e:
        raise FileNotFoundError(f"XML file not found: {xml_path}") from e

    # Try to decode as UTF-8 (safe for typical outputs)
    try:
        xml_text = xml_bytes.decode('utf-8')
    except UnicodeDecodeError:
        # fallback: let xmlschema handle bytes input
        xml_text = xml_bytes

    return validate_pain001_xml(xml_text, schema_path)


# --- Basic MT103 structural validator (heuristic) ---

_MT103_REQUIRED_TAGS = [":20:", ":32A:", ":50K:", ":59:", ":71A:"]

def _find_tag(mt_text: str, tag: str) -> Optional[re.Match]:
    """Return the regex match for tag content if present (simple heuristic)."""
    # Tags begin with colon and end at the next line that starts with colon-tag or block end.
    # This is a lightweight heuristic and not a full parser.
    pattern = re.compile(re.escape(tag) + r"(.*?)(?=\n:|$)", re.DOTALL)
    return pattern.search(mt_text)

def validate_mt103_text(mt_text: str) -> Tuple[bool, List[str]]:
    """
    Perform basic structural checks on an MT103-like message text.

    Returns:
      (is_valid, list_of_issues) where issues is empty when valid.

    Checks performed (heuristic):
      - Required tags present: :20:, :32A:, :50K:, :59:, :71A:
      - :32A: has format YYMMDD + 3-letter currency + amount (amount uses '.' as decimal separator)
    """
    issues = []

    # Check presence of tags
    for tag in _MT103_REQUIRED_TAGS:
        if not _find_tag(mt_text, tag):
            issues.append(f"Missing required tag {tag}")

    # Validate :32A:
    m = _find_tag(mt_text, ":32A:")
    if m:
        content = m.group(1).strip()
        # Expecting pattern: YYMMDD<CCC><AMOUNT>  e.g. 230731USD1234.56 or 230731USD1234
        m32 = re.match(r"^(\d{6})([A-Z]{3})(\d+(?:\.\d{1,2})?)$", content)
        if not m32:
            issues.append(f":32A: field has invalid format (expected YYMMDDCCCamount). Found: '{content}'")
    else:
        # already reported missing tag
        pass

    # Simple check for :50K: and :59: not empty
    for tag in (":50K:", ":59:"):
        mm = _find_tag(mt_text, tag)
        if mm:
            if not mm.group(1).strip():
                issues.append(f"{tag} tag is present but empty")

    is_valid = len(issues) == 0
    return is_valid, issues


# --- Simple convenience wrapper to validate pain.001 generated by swift_messages ---

def validate_pain001_generated(xml_string: str, schema_path: str) -> Tuple[bool, Optional[List[str]]]:
    """
    Convenience wrapper: ensures XML is well-formed and then validates against schema.
    Returns same tuple as validate_pain001_xml.
    """
    # First check well-formedness
    try:
        ET.fromstring(xml_string)
    except ET.ParseError as e:
        return False, [f"XML not well-formed: {e}"]

    return validate_pain001_xml(xml_string, schema_path)


# --- Example usage (for quick manual testing) ---
if __name__ == "__main__":
    import sys
    import textwrap

    if len(sys.argv) < 3:
        print(textwrap.dedent("""\
            Usage:
              python swift_iso_validator.py <xml_file_or_mt_file> <schema.xsd>  # for pain.001 validate
            Examples:
              python swift_iso_validator.py samples/sample_pain001.xml schemas/pain.001.001.03.xsd
            """))
        sys.exit(1)

    xml_file = sys.argv[1]
    schema = sys.argv[2]

    # Try pain.001 file validation
    try:
        valid, errs = validate_pain001_file(xml_file, schema)
        if valid:
            print("ISO20022 validation: VALID")
        else:
            print("ISO20022 validation: INVALID")
            for e in errs:
                print(" -", e)
    except SchemaNotFoundError as e:
        print("Schema error:", e)
    except Exception as e:
        print("Validation failed:", e)